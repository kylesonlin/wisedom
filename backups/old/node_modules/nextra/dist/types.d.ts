import { Heading as Heading$1 } from 'mdast';
import { Metadata, NextConfig } from 'next';
import { ReactElement, FC, ReactNode } from 'react';
import { z } from 'zod';
import { nextraConfigSchema, mathJaxOptionsSchema, metaSchema, separatorItemSchema, menuSchema } from './server/schemas.js';
import './lib/index.js';
import 'rehype-katex/lib/index.js';
import 'better-react-mathjax';
import 'rehype-pretty-code';

interface LoaderOptions extends z.infer<typeof nextraConfigSchema> {
    isPageImport?: boolean;
    locales: string[];
    contentDir?: string;
    shouldAddLocaleToLinks?: boolean;
}
type TPageItem = {
    name: string;
    route: string;
    __pagePath: string;
};
type TMetaItem = {
    __metaPath: string;
};
interface TFolder<T = TItem> {
    name: string;
    route: string;
    children: T[];
}
type TItem = TPageItem | TMetaItem | TFolder;
interface Folder<FileType = PageMapItem> {
    name: string;
    route: string;
    children: FileType[];
}
type Import = {
    importName: string;
    filePath: string;
};
type MetaJsonFile = {
    data: {
        [fileName: string]: Meta;
    };
};
type DynamicFolder = {
    items: DynamicMeta;
    title?: string;
};
type DynamicMetaItem = Meta | DynamicFolder;
type DynamicMeta = Record<string, DynamicMetaItem>;
type FrontMatter = Record<string, any>;
type Meta = string | Record<string, any>;
type MdxFile<FrontMatterType = FrontMatter> = {
    name: string;
    route: string;
    frontMatter?: FrontMatterType;
};
type PageMapItem = Folder | MdxFile | MetaJsonFile;
type Page = (MdxFile | Folder<Page>) & {
    meta?: Exclude<Meta, string>;
};
type Heading = {
    depth: Exclude<Heading$1['depth'], 1>;
    value: string | ReactElement;
    id: string;
};
type $NextraMetadata = Omit<Metadata, 'title'> & {
    title: string;
    filePath: string;
    timestamp?: number;
    readingTime?: ReadingTime;
};
type ReadingTime = {
    text: string;
    minutes: number;
    time: number;
    words: number;
};
type NextraConfig = z.input<typeof nextraConfigSchema>;
type MathJaxOptions = z.infer<typeof mathJaxOptionsSchema>;
type Nextra = (nextraConfig: NextraConfig) => (nextConfig: NextConfig) => NextConfig;
type MDXWrapper = FC<{
    toc: Heading[];
    children: ReactNode;
    metadata: $NextraMetadata;
    bottomContent?: ReactNode;
}>;
type MetaRecord = Record<string, z.infer<typeof metaSchema>>;
type SeparatorItem = z.infer<typeof separatorItemSchema>;
type MenuItem = z.infer<typeof menuSchema>;
/** Options that can be passed to pagefind.search() */
type PagefindSearchOptions = {
    /** If set, this call will load all assets but return before searching. Prefer using pagefind.preload() instead */
    preload?: boolean;
    /** Add more verbose console logging for this search query */
    verbose?: boolean;
    /** The set of filters to execute with this search. Input type is extremely flexible, see the filtering docs for details */
    filters?: object;
    /** The set of sorts to use for this search, instead of relevancy */
    sort?: object;
};
type NextraMetadata = Metadata & {
    asIndexPage?: boolean;
    sidebarTitle?: string;
};

export type { $NextraMetadata, DynamicFolder, DynamicMeta, DynamicMetaItem, Folder, FrontMatter, Heading, Import, LoaderOptions, MDXWrapper, MathJaxOptions, MdxFile, MenuItem, Meta, MetaJsonFile, MetaRecord, Nextra, NextraConfig, NextraMetadata, Page, PageMapItem, PagefindSearchOptions, ReadingTime, SeparatorItem, TItem };

import { rendererRich } from "@shikijs/twoslash";
import { fromMarkdown } from "mdast-util-from-markdown";
import { gfmFromMarkdown } from "mdast-util-gfm";
import { defaultHandlers, toHast } from "mdast-util-to-hast";
function renderMarkdown(md) {
  const mdast = fromMarkdown(
    md.replaceAll(/{@link (?<link>[^}]*)}/g, "$1"),
    // replace jsdoc links
    { mdastExtensions: [gfmFromMarkdown()] }
  );
  return toHast(mdast, {
    handlers: {
      code: (state, node) => {
        if (node.lang) {
          return this.codeToHast(node.value, {
            ...this.options,
            transformers: [],
            meta: {
              __raw: node.meta ?? void 0
            },
            lang: node.lang
          }).children[0];
        }
        return defaultHandlers.code(state, node);
      }
    }
  }).children;
}
function renderMarkdownInline(md, context) {
  const text = context === "tag:param" ? md.replace(/^(?<link>[\w$-]+)/, "`$1` ") : md;
  const children = renderMarkdown.call(this, text);
  const [firstChild] = children;
  if (children.length === 1 && firstChild && firstChild.type === "element" && firstChild.tagName === "p")
    return firstChild.children;
  return children;
}
function twoslashRenderer(options) {
  return rendererRich({
    ...options,
    renderMarkdown,
    renderMarkdownInline,
    hast: {
      hoverToken: { tagName: "Popup" },
      hoverPopup: { tagName: "PopupPanel" },
      hoverCompose: ({ popup, token }) => [
        popup,
        {
          type: "element",
          tagName: "PopupButton",
          properties: {},
          children: [token]
        }
      ],
      ...options?.hast
    }
  });
}
export {
  twoslashRenderer
};

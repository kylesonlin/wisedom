import { fromZodError } from "zod-validation-error";
import { metaSchema } from "../schemas.js";
import { pageTitleFromFilename } from "../utils.js";
function normalizePageMap(pageMap) {
  if (Array.isArray(pageMap)) {
    return sortFolder(
      pageMap.map((item) => "children" in item ? normalizePageMap(item) : item)
    );
  }
  return sortFolder(pageMap);
}
function titlize(item, meta) {
  const titleFromMeta = meta[item.name]?.title;
  if (titleFromMeta) return titleFromMeta;
  if ("frontMatter" in item && item.frontMatter) {
    const titleFromFrontMatter = item.frontMatter.sidebarTitle || item.frontMatter.title;
    if (titleFromFrontMatter) return titleFromFrontMatter;
  }
  return pageTitleFromFilename(item.name);
}
function sortFolder(pageMap) {
  const newChildren = [];
  const isFolder = !Array.isArray(pageMap);
  const folder = isFolder ? { ...pageMap } : { children: pageMap };
  const meta = {};
  for (const item of folder.children) {
    if (isFolder && "frontMatter" in item && item.frontMatter?.asIndexPage && item.route === folder.route) {
      folder.frontMatter = item.frontMatter;
    } else if ("children" in item) {
      newChildren.push(normalizePageMap(item));
    } else if ("data" in item) {
      for (const [key, titleOrObject] of Object.entries(item.data)) {
        const { data, error } = metaSchema.safeParse(titleOrObject);
        if (error) {
          throw fromZodError(error);
        }
        if (key === "*") {
          delete data.title;
          delete data.href;
        }
        meta[key] = data;
      }
    } else {
      newChildren.push(item);
    }
  }
  const metaKeys = Object.keys(meta);
  const hasIndexKey = metaKeys.includes("index");
  const items = newChildren.sort((a, b) => {
    const indexA = metaKeys.indexOf(a.name);
    const indexB = metaKeys.indexOf(b.name);
    if (!hasIndexKey) {
      if (b.name === "index") return 1;
      if (a.name === "index") return -1;
    }
    if (indexA === -1 && indexB === -1) return a.name < b.name ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
  for (const [index, metaKey] of metaKeys.filter((key) => key !== "*").entries()) {
    const metaItem = meta[metaKey];
    const item = items.find((item2) => item2.name === metaKey);
    if (metaItem.type === "menu" && item) {
      item.items = metaItem.items;
      const { children } = items.find(
        (i) => i.name === metaKey
      );
      for (const [key, value] of Object.entries(
        // @ts-expect-error fixme
        item.items
      )) {
        if (!value.href && children.every((i) => i.name !== key)) {
          throw new Error(
            `Validation of "_meta" file has failed.
The field key "${metaKey}.items.${key}" in \`_meta\` file refers to a page that cannot be found, remove this key from "_meta" file.`
          );
        }
      }
    }
    if (item) continue;
    const isValid = metaItem.type === "separator" || metaItem.type === "menu" || metaItem.href;
    if (!isValid) {
      throw new Error(
        `Validation of "_meta" file has failed.
The field key "${metaKey}" in \`_meta\` file refers to a page that cannot be found, remove this key from "_meta" file.`
      );
    }
    const currentItem = items[index];
    if (currentItem && currentItem.name === metaKey) continue;
    items.splice(
      index,
      // index at which to start changing the array
      0,
      // remove zero items
      // @ts-expect-error fixme
      { name: metaKey, ...meta[metaKey] }
    );
  }
  if (metaKeys.length) {
    items.unshift({ data: meta });
  }
  const itemsWithTitle = items.map((item) => {
    const isSeparator = "type" in item && item.type === "separator";
    if ("name" in item && !isSeparator) {
      return {
        ...item,
        title: titlize(item, meta)
      };
    }
    return item;
  });
  const result = isFolder ? {
    ...folder,
    title: titlize(folder, {}),
    children: itemsWithTitle
  } : itemsWithTitle;
  return result;
}
export {
  normalizePageMap
};

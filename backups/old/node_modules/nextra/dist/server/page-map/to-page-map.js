import path from "path";
import { normalizeAppPath } from "next/dist/shared/lib/router/utils/app-paths.js";
function createNested(map, path2) {
  let current = map;
  for (const part of path2.split("/")) {
    current[part] ||= {};
    current = current[part];
  }
}
const APP_DIR_SUFFIX_RE = /^(src\/)?app\//;
function convertToPageMap({
  filePaths,
  basePath,
  locale
}) {
  const pages = {};
  const metaFiles = {};
  const nestedMap = {};
  for (const filePath of filePaths) {
    let { name, dir } = path.parse(filePath);
    const inAppDir = APP_DIR_SUFFIX_RE.test(filePath);
    if (inAppDir) {
      dir = dir.replace(/^(src\/)?app(\/|$)/, "");
    } else {
      let filePath2 = dir.replace(/^(src\/)?content(\/|$)/, "");
      if (locale) filePath2 = filePath2.replace(new RegExp(`^${locale}/?`), "");
      dir = [basePath, filePath2].filter(Boolean).join("/");
    }
    if (name === "_meta") {
      const key = dir ? `${dir}/${name}` : name;
      metaFiles[key] = filePath;
    } else if (name !== "_meta.global") {
      const key = inAppDir ? (
        // In Next.js we can organize routes without affecting the URL
        // https://nextjs.org/docs/app/building-your-application/routing/route-groups#organize-routes-without-affecting-the-url-path
        //
        // E.g. we have the following filepath:
        // app/posts/(with-comments)/aaron-swartz-a-programmable-web/()/page.mdx
        //
        // will be normalized to:
        // app/posts/aaron-swartz-a-programmable-web/page.mdx
        //
        // The `normalizeAppPath` function ensures a leading slash is present, so we slice it off.
        normalizeAppPath(dir).slice(1)
      ) : [dir, name !== "index" && name].filter(Boolean).join("/");
      pages[key] = filePath;
    }
  }
  for (const path2 of Object.keys(metaFiles)) {
    createNested(nestedMap, path2);
  }
  for (const path2 of Object.keys(pages)) {
    createNested(nestedMap, path2 && `${path2}/`);
  }
  function fillPageMap(obj, prefix) {
    return Object.entries(obj).map(([key, value]) => {
      const path2 = prefix && key ? `${prefix}/${key}` : prefix || key;
      if (key === "_meta") {
        const __metaPath = metaFiles[path2];
        if (!__metaPath) {
          const o = JSON.stringify({ path: path2, metaFiles }, null, 2);
          throw new Error(`Can't find "_meta" file for:
${o}`);
        }
        return { __metaPath };
      }
      const item = {
        name: key || "index",
        route: `/${path2}`
      };
      const keys = Object.keys(value);
      const isFolder = keys.length > 1 || keys.length === 1 && keys[0] !== "";
      if (isFolder) {
        return { ...item, children: fillPageMap(value, path2) };
      }
      const __pagePath = pages[path2];
      if (!__pagePath) {
        const o = JSON.stringify({ path: path2, mdxPages: pages }, null, 2);
        throw new Error(`Can't find "page" file for:
${o}`);
      }
      return { ...item, __pagePath };
    });
  }
  const pageMap = fillPageMap(nestedMap);
  const mdxPages = Object.fromEntries(
    Object.entries(pages).flatMap(([key, value]) => {
      if (basePath) key = key.replace(new RegExp(`^${basePath}/?`), "");
      value = value.replace(/^(src\/)?content\//, "");
      if (locale) value = value.replace(new RegExp(`^${locale}/`), "");
      if (APP_DIR_SUFFIX_RE.test(value)) {
        return [];
      }
      return [[key, value]];
    })
  );
  return { pageMap, mdxPages };
}
export {
  convertToPageMap
};

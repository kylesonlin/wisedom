import { valueToEstree } from "estree-util-value-to-estree";
import { visit } from "unist-util-visit";
const MATHJAX_IMPORTS = {
  type: "mdxjsEsm",
  data: {
    estree: {
      body: [
        {
          type: "ImportDeclaration",
          source: { type: "Literal", value: "nextra/components" },
          specifiers: ["MathJax", "MathJaxContext"].map((name) => ({
            type: "ImportSpecifier",
            imported: { type: "Identifier", name },
            local: { type: "Identifier", name }
          }))
        }
      ]
    }
  }
};
function wrapInMathJaxContext(children, { config, src }) {
  const attributes = [];
  if (src) {
    attributes.push({ type: "mdxJsxAttribute", name: "src", value: src });
  }
  if (config && Object.keys(config).length) {
    attributes.push({
      type: "mdxJsxAttribute",
      name: "config",
      value: {
        type: "mdxJsxAttributeValueExpression",
        value: "",
        data: {
          estree: {
            type: "Program",
            sourceType: "module",
            body: [
              { type: "ExpressionStatement", expression: valueToEstree(config) }
            ]
          }
        }
      }
    });
  }
  return {
    type: "mdxJsxFlowElement",
    name: "MathJaxContext",
    attributes,
    children
  };
}
function wrapInBraces(source, mathInline, options) {
  const { inlineMath, displayMath } = options.config?.tex || {};
  const inlineBraces = inlineMath?.[0] || [String.raw`\(`, String.raw`\)`];
  const displayBraces = displayMath?.[0] || [String.raw`\[`, String.raw`\]`];
  const [before, after] = mathInline ? inlineBraces : displayBraces;
  return `${before}${source}${after}`;
}
const rehypeBetterReactMathjax = (options = {}, isRemoteContent) => (ast) => {
  let hasMathJax = false;
  visit(ast, { tagName: "code" }, (node, _index, parent) => {
    const classes = Array.isArray(node.properties.className) ? node.properties.className : [];
    const hasMathLanguage = classes.includes("language-math");
    if (!hasMathLanguage) return;
    const isInlineMath = classes.includes("math-inline");
    const [{ value }] = node.children;
    const bracketedValue = wrapInBraces(value, isInlineMath, options);
    const mathJaxNode = {
      type: "element",
      tagName: "MathJax",
      children: [{ type: "text", value: bracketedValue }],
      properties: isInlineMath ? { inline: true } : {}
    };
    Object.assign(isInlineMath ? node : parent, mathJaxNode);
    hasMathJax = true;
  });
  if (!hasMathJax) return;
  const mdxjsEsmNodes = [];
  const rest = [];
  for (const child of ast.children) {
    if (child.type === "mdxjsEsm") {
      mdxjsEsmNodes.push(child);
    } else {
      rest.push(child);
    }
  }
  ast.children = [
    ...mdxjsEsmNodes,
    ...isRemoteContent ? [] : [MATHJAX_IMPORTS],
    // Wrap everything in a `<MathJaxContext>` component.
    wrapInMathJaxContext(rest, options)
  ];
};
export {
  rehypeBetterReactMathjax
};

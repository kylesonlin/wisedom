import Slugger from "github-slugger";
import { visit } from "unist-util-visit";
import { visitChildren } from "unist-util-visit-children";
import { MARKDOWN_EXTENSION_RE } from "../constants.js";
import { createAstObject } from "../utils.js";
const getFlattenedValue = (node) => node.children.map(
  (child) => "children" in child ? getFlattenedValue(child) : "value" in child ? child.value : ""
).join("");
const remarkHeadings = ({ exportName = "toc", isRemoteContent }) => {
  const headings = [];
  const slugger = new Slugger();
  return (ast, file) => {
    const PartialComponentToHeadingsName = /* @__PURE__ */ Object.create(null);
    visit(
      ast,
      [
        "heading",
        // push partial component's `toc` export name to headings list
        "mdxJsxFlowElement",
        // verify .md/.mdx exports and attach named `toc` export
        "mdxjsEsm"
      ],
      (node, index, parent) => {
        if (node.type === "heading") {
          if (node.depth === 1) {
            return;
          }
          node.data ||= {};
          const headingProps = node.data.hProperties ||= {};
          const value = getFlattenedValue(node);
          const id = slugger.slug(headingProps.id || value);
          headingProps.id = id;
          headings.push({ depth: node.depth, value, id });
          return;
        }
        const isTab = node.type === "mdxJsxFlowElement" && node.name === "Tabs.Tab";
        if (isTab) {
          const itemsAttr = parent && parent.type === "mdxJsxFlowElement" && parent.name === "Tabs" && parent.attributes.find(
            (attr) => attr.type === "mdxJsxAttribute" && attr.name === "items"
          );
          if (!itemsAttr) return;
          const tabName = itemsAttr.value.data.estree.body[0].expression.elements.map(
            (el) => el.value
          )[index];
          const id = slugger.slug(tabName);
          node.children.unshift({
            type: "mdxJsxFlowElement",
            name: "h3",
            data: { _mdxExplicitJsx: true },
            children: [{ type: "text", value: tabName }],
            attributes: [
              { type: "mdxJsxAttribute", name: "id", value: id },
              {
                type: "mdxJsxAttribute",
                name: "style",
                value: {
                  type: "mdxJsxAttributeValueExpression",
                  value: "",
                  data: {
                    estree: {
                      type: "Program",
                      sourceType: "module",
                      comments: [],
                      body: [
                        {
                          type: "ExpressionStatement",
                          expression: createAstObject({
                            visibility: "hidden",
                            width: 0,
                            height: 0
                          })
                        }
                      ]
                    }
                  }
                }
              }
            ]
          });
        }
        const isDetails = node.type === "mdxJsxFlowElement" && node.name === "details";
        if (isDetails) {
          const visitor = visitChildren((node2) => {
            const isSummary = node2.type === "mdxJsxTextElement" && node2.name === "summary";
            if (isSummary) {
              const value = getFlattenedValue(node2);
              const id = slugger.slug(value);
              node2.attributes.push({
                type: "mdxJsxAttribute",
                name: "id",
                value: id
              });
            } else if ("children" in node2) {
              visitor(node2);
            }
          });
          visitor(node);
        }
        if (isRemoteContent) {
        } else if (node.type === "mdxjsEsm") {
          for (const child of node.data.estree.body) {
            if (child.type !== "ImportDeclaration") continue;
            const importPath = child.source.value;
            const isMdxImport = MARKDOWN_EXTENSION_RE.test(importPath);
            if (!isMdxImport) continue;
            const componentName = child.specifiers.find(
              (o) => o.type === "ImportDefaultSpecifier"
            )?.local.name;
            if (!componentName) continue;
            const { length } = Object.keys(PartialComponentToHeadingsName);
            const exportAsName = `${exportName}${length}`;
            PartialComponentToHeadingsName[componentName] = exportAsName;
            child.specifiers.push({
              type: "ImportSpecifier",
              imported: { type: "Identifier", name: exportName },
              local: { type: "Identifier", name: exportAsName }
            });
          }
        } else {
          const headingsName = PartialComponentToHeadingsName[node.name];
          if (headingsName) {
            headings.push(headingsName);
          }
        }
      }
    );
    file.data.toc = headings;
  };
};
export {
  getFlattenedValue,
  remarkHeadings
};

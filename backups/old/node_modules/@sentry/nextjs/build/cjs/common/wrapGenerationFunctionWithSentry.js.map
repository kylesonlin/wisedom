{"version":3,"file":"wrapGenerationFunctionWithSentry.js","sources":["../../../src/common/wrapGenerationFunctionWithSentry.ts"],"sourcesContent":["import type { RequestEventData, WebFetchHeaders } from '@sentry/core';\nimport {\n  captureException,\n  getActiveSpan,\n  getCapturedScopesOnSpan,\n  getClient,\n  getRootSpan,\n  handleCallbackErrors,\n  propagationContextFromHeaders,\n  Scope,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  setCapturedScopesOnSpan,\n  SPAN_STATUS_ERROR,\n  SPAN_STATUS_OK,\n  startSpanManual,\n  winterCGHeadersToDict,\n  withIsolationScope,\n  withScope,\n} from '@sentry/core';\nimport type { GenerationFunctionContext } from '../common/types';\nimport { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils';\nimport { TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL } from './span-attributes-with-logic-attached';\nimport { commonObjectToIsolationScope, commonObjectToPropagationContext } from './utils/tracingUtils';\n\n/**\n * Wraps a generation function (e.g. generateMetadata) with Sentry error and performance instrumentation.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function wrapGenerationFunctionWithSentry<F extends (...args: any[]) => any>(\n  generationFunction: F,\n  context: GenerationFunctionContext,\n): F {\n  const { requestAsyncStorage, componentRoute, componentType, generationFunctionIdentifier } = context;\n  return new Proxy(generationFunction, {\n    apply: (originalFunction, thisArg, args) => {\n      const requestTraceId = getActiveSpan()?.spanContext().traceId;\n      let headers: WebFetchHeaders | undefined = undefined;\n      // We try-catch here just in case anything goes wrong with the async storage here goes wrong since it is Next.js internal API\n      try {\n        headers = requestAsyncStorage?.getStore()?.headers;\n      } catch (e) {\n        /** empty */\n      }\n\n      const isolationScope = commonObjectToIsolationScope(headers);\n\n      const activeSpan = getActiveSpan();\n      if (activeSpan) {\n        const rootSpan = getRootSpan(activeSpan);\n        const { scope } = getCapturedScopesOnSpan(rootSpan);\n        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);\n      }\n\n      let data: Record<string, unknown> | undefined = undefined;\n      if (getClient()?.getOptions().sendDefaultPii) {\n        const props: unknown = args[0];\n        const params = props && typeof props === 'object' && 'params' in props ? props.params : undefined;\n        const searchParams =\n          props && typeof props === 'object' && 'searchParams' in props ? props.searchParams : undefined;\n        data = { params, searchParams };\n      }\n\n      const headersDict = headers ? winterCGHeadersToDict(headers) : undefined;\n\n      return withIsolationScope(isolationScope, () => {\n        return withScope(scope => {\n          scope.setTransactionName(`${componentType}.${generationFunctionIdentifier} (${componentRoute})`);\n\n          isolationScope.setSDKProcessingMetadata({\n            normalizedRequest: {\n              headers: headersDict,\n            } satisfies RequestEventData,\n          });\n\n          const activeSpan = getActiveSpan();\n          if (activeSpan) {\n            const rootSpan = getRootSpan(activeSpan);\n            const sentryTrace = headersDict?.['sentry-trace'];\n            if (sentryTrace) {\n              rootSpan.setAttribute(TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL, sentryTrace);\n            }\n          }\n\n          const propagationContext = commonObjectToPropagationContext(\n            headers,\n            propagationContextFromHeaders(headersDict?.['sentry-trace'], headersDict?.['baggage']),\n          );\n\n          if (requestTraceId) {\n            propagationContext.traceId = requestTraceId;\n          }\n\n          scope.setPropagationContext(propagationContext);\n\n          scope.setExtra('route_data', data);\n\n          return startSpanManual(\n            {\n              op: 'function.nextjs',\n              name: `${componentType}.${generationFunctionIdentifier} (${componentRoute})`,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs',\n              },\n            },\n            span => {\n              return handleCallbackErrors(\n                () => originalFunction.apply(thisArg, args),\n                err => {\n                  // When you read this code you might think: \"Wait a minute, shouldn't we set the status on the root span too?\"\n                  // The answer is: \"No.\" - The status of the root span is determined by whatever status code Next.js decides to put on the response.\n                  if (isNotFoundNavigationError(err)) {\n                    // We don't want to report \"not-found\"s\n                    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'not_found' });\n                    getRootSpan(span).setStatus({ code: SPAN_STATUS_ERROR, message: 'not_found' });\n                  } else if (isRedirectNavigationError(err)) {\n                    // We don't want to report redirects\n                    span.setStatus({ code: SPAN_STATUS_OK });\n                  } else {\n                    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n                    getRootSpan(span).setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n                    captureException(err, {\n                      mechanism: {\n                        handled: false,\n                      },\n                    });\n                  }\n                },\n                () => {\n                  span.end();\n                },\n              );\n            },\n          );\n        });\n      });\n    },\n  });\n}\n"],"names":["getActiveSpan","commonObjectToIsolationScope","getRootSpan","getCapturedScopesOnSpan","setCapturedScopesOnSpan","Scope","getClient","winterCGHeadersToDict","withIsolationScope","withScope","TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL","commonObjectToPropagationContext","propagationContextFromHeaders","startSpanManual","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","handleCallbackErrors","isNotFoundNavigationError","SPAN_STATUS_ERROR","isRedirectNavigationError","SPAN_STATUS_OK","captureException"],"mappings":";;;;;;;AAyBA;AACA;AACA;AACA;AACO,SAAS,gCAAgC;AAChD,EAAE,kBAAkB;AACpB,EAAE,OAAO;AACT,EAAK;AACL,EAAE,MAAM,EAAE,mBAAmB,EAAE,cAAc,EAAE,aAAa,EAAE,4BAAA,EAA+B,GAAE,OAAO;AACtG,EAAE,OAAO,IAAI,KAAK,CAAC,kBAAkB,EAAE;AACvC,IAAI,KAAK,EAAE,CAAC,gBAAgB,EAAE,OAAO,EAAE,IAAI,KAAK;AAChD,MAAM,MAAM,cAAe,GAAEA,kBAAa,EAAE,EAAE,WAAW,EAAE,CAAC,OAAO;AACnE,MAAM,IAAI,OAAO,GAAgC,SAAS;AAC1D;AACA,MAAM,IAAI;AACV,QAAQ,OAAA,GAAU,mBAAmB,EAAE,QAAQ,EAAE,EAAE,OAAO;AAC1D,OAAQ,CAAA,OAAO,CAAC,EAAE;AAClB;AACA;;AAEA,MAAM,MAAM,cAAe,GAAEC,yCAA4B,CAAC,OAAO,CAAC;;AAElE,MAAM,MAAM,UAAA,GAAaD,kBAAa,EAAE;AACxC,MAAM,IAAI,UAAU,EAAE;AACtB,QAAQ,MAAM,QAAS,GAAEE,gBAAW,CAAC,UAAU,CAAC;AAChD,QAAQ,MAAM,EAAE,KAAM,EAAA,GAAIC,4BAAuB,CAAC,QAAQ,CAAC;AAC3D,QAAQC,4BAAuB,CAAC,QAAQ,EAAE,KAAM,IAAG,IAAIC,UAAK,EAAE,EAAE,cAAc,CAAC;AAC/E;;AAEA,MAAM,IAAI,IAAI,GAAwC,SAAS;AAC/D,MAAM,IAAIC,cAAS,EAAE,EAAE,UAAU,EAAE,CAAC,cAAc,EAAE;AACpD,QAAQ,MAAM,KAAK,GAAY,IAAI,CAAC,CAAC,CAAC;AACtC,QAAQ,MAAM,MAAO,GAAE,SAAS,OAAO,UAAU,QAAA,IAAY,QAAA,IAAY,KAAM,GAAE,KAAK,CAAC,MAAA,GAAS,SAAS;AACzG,QAAQ,MAAM,YAAa;AAC3B,UAAU,KAAM,IAAG,OAAO,KAAA,KAAU,QAAS,IAAG,cAAe,IAAG,QAAQ,KAAK,CAAC,YAAA,GAAe,SAAS;AACxG,QAAQ,OAAO,EAAE,MAAM,EAAE,cAAc;AACvC;;AAEA,MAAM,MAAM,WAAY,GAAE,OAAQ,GAAEC,0BAAqB,CAAC,OAAO,CAAE,GAAE,SAAS;;AAE9E,MAAM,OAAOC,uBAAkB,CAAC,cAAc,EAAE,MAAM;AACtD,QAAQ,OAAOC,cAAS,CAAC,KAAA,IAAS;AAClC,UAAU,KAAK,CAAC,kBAAkB,CAAC,CAAC,EAAA,aAAA,CAAA,CAAA,EAAA,4BAAA,CAAA,EAAA,EAAA,cAAA,CAAA,CAAA,CAAA,CAAA;;AAEA,UAAA,cAAA,CAAA,wBAAA,CAAA;AACA,YAAA,iBAAA,EAAA;AACA,cAAA,OAAA,EAAA,WAAA;AACA,aAAA;AACA,WAAA,CAAA;;AAEA,UAAA,MAAA,UAAA,GAAAT,kBAAA,EAAA;AACA,UAAA,IAAA,UAAA,EAAA;AACA,YAAA,MAAA,QAAA,GAAAE,gBAAA,CAAA,UAAA,CAAA;AACA,YAAA,MAAA,WAAA,GAAA,WAAA,GAAA,cAAA,CAAA;AACA,YAAA,IAAA,WAAA,EAAA;AACA,cAAA,QAAA,CAAA,YAAA,CAAAQ,sEAAA,EAAA,WAAA,CAAA;AACA;AACA;;AAEA,UAAA,MAAA,kBAAA,GAAAC,6CAAA;AACA,YAAA,OAAA;AACA,YAAAC,kCAAA,CAAA,WAAA,GAAA,cAAA,CAAA,EAAA,WAAA,GAAA,SAAA,CAAA,CAAA;AACA,WAAA;;AAEA,UAAA,IAAA,cAAA,EAAA;AACA,YAAA,kBAAA,CAAA,OAAA,GAAA,cAAA;AACA;;AAEA,UAAA,KAAA,CAAA,qBAAA,CAAA,kBAAA,CAAA;;AAEA,UAAA,KAAA,CAAA,QAAA,CAAA,YAAA,EAAA,IAAA,CAAA;;AAEA,UAAA,OAAAC,oBAAA;AACA,YAAA;AACA,cAAA,EAAA,EAAA,iBAAA;AACA,cAAA,IAAA,EAAA,CAAA,EAAA,aAAA,CAAA,CAAA,EAAA,4BAAA,CAAA,EAAA,EAAA,cAAA,CAAA,CAAA,CAAA;AACA,cAAA,UAAA,EAAA;AACA,gBAAA,CAAAC,qCAAA,GAAA,OAAA;AACA,gBAAA,CAAAC,qCAAA,GAAA,sBAAA;AACA,eAAA;AACA,aAAA;AACA,YAAA,IAAA,IAAA;AACA,cAAA,OAAAC,yBAAA;AACA,gBAAA,MAAA,gBAAA,CAAA,KAAA,CAAA,OAAA,EAAA,IAAA,CAAA;AACA,gBAAA,GAAA,IAAA;AACA;AACA;AACA,kBAAA,IAAAC,kDAAA,CAAA,GAAA,CAAA,EAAA;AACA;AACA,oBAAA,IAAA,CAAA,SAAA,CAAA,EAAA,IAAA,EAAAC,sBAAA,EAAA,OAAA,EAAA,WAAA,EAAA,CAAA;AACA,oBAAAhB,gBAAA,CAAA,IAAA,CAAA,CAAA,SAAA,CAAA,EAAA,IAAA,EAAAgB,sBAAA,EAAA,OAAA,EAAA,WAAA,EAAA,CAAA;AACA,mBAAA,MAAA,IAAAC,kDAAA,CAAA,GAAA,CAAA,EAAA;AACA;AACA,oBAAA,IAAA,CAAA,SAAA,CAAA,EAAA,IAAA,EAAAC,mBAAA,EAAA,CAAA;AACA,mBAAA,MAAA;AACA,oBAAA,IAAA,CAAA,SAAA,CAAA,EAAA,IAAA,EAAAF,sBAAA,EAAA,OAAA,EAAA,gBAAA,EAAA,CAAA;AACA,oBAAAhB,gBAAA,CAAA,IAAA,CAAA,CAAA,SAAA,CAAA,EAAA,IAAA,EAAAgB,sBAAA,EAAA,OAAA,EAAA,gBAAA,EAAA,CAAA;AACA,oBAAAG,qBAAA,CAAA,GAAA,EAAA;AACA,sBAAA,SAAA,EAAA;AACA,wBAAA,OAAA,EAAA,KAAA;AACA,uBAAA;AACA,qBAAA,CAAA;AACA;AACA,iBAAA;AACA,gBAAA,MAAA;AACA,kBAAA,IAAA,CAAA,GAAA,EAAA;AACA,iBAAA;AACA,eAAA;AACA,aAAA;AACA,WAAA;AACA,SAAA,CAAA;AACA,OAAA,CAAA;AACA,KAAA;AACA,GAAA,CAAA;AACA;;;;"}